#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Universal Xerox FreeFlow to Papyrus DocDEF Converter

This tool converts Xerox FreeFlow Designer files (DBM and FRM) to Papyrus DocDEF (DFA) format.

Created by: Claude 3.7 Sonnet
Date: April 28, 2025
"""

# ===== SECTION 1: IMPORTS =====
# Should include all these imports
import os
import re
import sys
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Tuple, Union, Any
import argparse
import json
from datetime import datetime
import traceback

# Import command mappings
from command_mappings import (
    VIPP_TO_DFA_COMMANDS,
    VIPP_TO_DFA_ALIGNMENT,
    VIPP_TO_DFA_FONTS,
    VIPP_TO_DFA_COLORS,
    VIPP_BOX_PARAMS,
    VIPP_SPECIAL_COMMANDS,
    VIPP_TO_DFA_OPERATORS,
    VIPP_TO_DFA_SYSTEM_VARS,
    VIPP_TO_DFA_FUNCTIONS,
    translate_vipp_command,
    translate_output_command,
    translate_position_command,
    translate_box_command,
    translate_resource_command,
    translate_variable_assignment,
    translate_conditional_command,
    translate_loop_command,
    translate_case_command,
    translate_txnb_command,
    translate_params
)

# ===== SECTION 2: LOGGING SETUP =====
# Should have logging configuration
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('XeroxParser')

# ===== SECTION 3: DATA CLASSES =====
# Should include all these data classes
@dataclass
class XeroxToken:
    """Represents a token in Xerox FreeFlow code."""
    type: str  # 'keyword', 'variable', 'string', 'number', 'operator', 'delimiter', 'comment'
    value: str
    line_number: int
    column: int
    
    def __str__(self):
        return f"{self.type}({self.value})"


@dataclass
class XeroxCommand:
    """Represents a parsed Xerox command with its parameters and content."""
    name: str
    parameters: List[Any] = field(default_factory=list)
    content: str = ""
    line_number: int = 0
    column: int = 0
    indentation: int = 0
    parent: Optional['XeroxCommand'] = None
    children: List['XeroxCommand'] = field(default_factory=list)
    tokens: List[XeroxToken] = field(default_factory=list)


@dataclass
class XeroxFont:
    """Represents a font definition in Xerox FreeFlow."""
    alias: str
    name: str
    size: float = 10.0
    bold: bool = False
    italic: bool = False
    rotation: int = 0
    additional_params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class XeroxColor:
    """Represents a color definition in Xerox FreeFlow."""
    alias: str
    name: str
    rgb: Optional[Tuple[int, int, int]] = None
    cmyk: Optional[Tuple[int, int, int, int]] = None


@dataclass
class XeroxVariable:
    """Represents a variable definition in Xerox FreeFlow."""
    name: str
    type: str = "string"  # string, number, array
    default_value: Any = None
    usage: Set[str] = field(default_factory=set)  # Where this variable is used
    dimensions: Optional[List[int]] = None  # For arrays


@dataclass
class XeroxProject:
    """Represents a full Xerox FreeFlow project."""
    name: str
    dbm_files: Dict[str, 'XeroxDBM'] = field(default_factory=dict)
    frm_files: Dict[str, 'XeroxFRM'] = field(default_factory=dict)
    resources: Dict[str, str] = field(default_factory=dict)  # resource_name -> file_path


@dataclass
class XeroxDBM:
    """Represents a parsed Xerox DBM file."""
    filename: str
    title: str = ""
    creator: str = ""
    creation_date: str = ""
    variables: Dict[str, XeroxVariable] = field(default_factory=dict)
    fonts: Dict[str, XeroxFont] = field(default_factory=dict)
    colors: Dict[str, XeroxColor] = field(default_factory=dict)
    wizvar_prefixes: List[str] = field(default_factory=list)
    wizvar_fields: List[str] = field(default_factory=list)
    commands: List[XeroxCommand] = field(default_factory=list)
    case_blocks: Dict[str, List[XeroxCommand]] = field(default_factory=dict)
    raw_content: str = ""
    tokens: List[XeroxToken] = field(default_factory=list)


@dataclass
class XeroxFRM:
    """Represents a parsed Xerox FRM file."""
    filename: str
    title: str = ""
    creator: str = ""
    creation_date: str = ""
    fonts: Dict[str, XeroxFont] = field(default_factory=dict)
    colors: Dict[str, XeroxColor] = field(default_factory=dict)
    commands: List[XeroxCommand] = field(default_factory=list)
    raw_content: str = ""
    tokens: List[XeroxToken] = field(default_factory=list)

# ===== SECTION 4: LEXER CLASS =====
# Should have a complete XeroxLexer class
class XeroxLexer:
    """Lexical analyzer for Xerox FreeFlow code."""
    
    # Token definitions
    KEYWORDS = {
        # VIPP structure and flow control
        'XGF', 'ENDXGF', 'SETPROJECT', 'ENDJOB', 'STARTDBM', 'ENDCASE', 'BEGINDOCUMENT', 'ENDDOCUMENT',
        'CASE', 'PREFIX', 'ENDPAGE', 'BEGINPAGE', 'FSHOW', 'SETPARAMS', 'SETUNIT', 'SETFTSW',
        'SETSUB', 'SETVARS', 'SETVAR', 'SETINFO', 'IF', 'ELSE', 'ENDIF', 'FOR', 'ENDFOR',
        'WHILE', 'ENDWHILE', 'REPEAT', 'BREAK', 'CONTINUE', 'GOTO',
        
        # Font and color handling
        'INDEXFONT', 'INDEXCOLOR', 'INDEXBAT', 'XGFRESDEF',
        
        # Page and positioning
        'SETPAGESIZE', 'SETLSP', 'SETPAGENUMBER', 'SETPAGEDEF', 'SETLKF', 'SETFORM',
        'MOVETO', 'MOVEH', 'LINETO', 'NL', 'ORITL', 'PORT', 'LAND', 'SHL', 'SHR', 'SHC', 'SHP',
        
        # Resource handling
        'CACHE', 'ICALL', 'SCALL', 'DRAWB',
        
        # Forms specific
        'MM', 'CM', 'INCH', 'POINT',
    }
    
    OPERATORS = {'+', '-', '*', '/', '=', '==', '!=', '<', '>', '<=', '>=', '!', '&&', '||', '++', '--'}
    
    DELIMITERS = {'(', ')', '[', ']', '{', '}', ',', ';', ':'}
    
    def __init__(self):
        self.input = ""
        self.tokens = []
        self.pos = 0
        self.line = 1
        self.col = 1
    
    def tokenize(self, input_text: str) -> List[XeroxToken]:
        """Convert the input string into a list of tokens."""
        self.input = input_text
        self.tokens = []
        self.pos = 0
        self.line = 1
        self.col = 1
        
        while self.pos < len(self.input):
            # Skip whitespace
            if self.input[self.pos].isspace():
                if self.input[self.pos] == '\n':
                    self.line += 1
                    self.col = 1
                else:
                    self.col += 1
                self.pos += 1
                continue
            
            # Handle comments
            if self.pos + 1 < len(self.input) and self.input[self.pos:self.pos+2] == '/*':
                self._handle_block_comment()
                continue
            
            if self.input[self.pos] == '%':
                self._handle_line_comment()
                continue
            
            # Handle string literals
            if self.input[self.pos] == "'":
                self._handle_string_literal("'")
                continue
            
            if self.input[self.pos] == '"':
                self._handle_string_literal('"')
                continue
            
            # Handle numbers
            if self.input[self.pos].isdigit() or (self.input[self.pos] == '.' and 
                                              self.pos + 1 < len(self.input) and 
                                              self.input[self.pos + 1].isdigit()):
                self._handle_number()
                continue
            
            # Handle identifiers and keywords
            if self.input[self.pos].isalpha() or self.input[self.pos] == '_' or self.input[self.pos] == '$':
                self._handle_identifier()
                continue
            
            # Handle Xerox-specific prefixes
            if self.input[self.pos] == '/':
                self._handle_xerox_identifier()
                continue
            
            # Handle operators
            if self.input[self.pos] in '+-*/=!<>&|':
                self._handle_operator()
                continue
            
            # Handle delimiters
            if self.input[self.pos] in self.DELIMITERS:
                token = XeroxToken(
                    type='delimiter',
                    value=self.input[self.pos],
                    line_number=self.line,
                    column=self.col
                )
                self.tokens.append(token)
                self.col += 1
                self.pos += 1
                continue
            
            # Handle unknown characters
            self.pos += 1
            self.col += 1
        
        return self.tokens
    
    def _handle_block_comment(self):
        """Handle a /* ... */ style comment."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        self.pos += 2  # Skip /*
        self.col += 2
        
        while self.pos < len(self.input) - 1:
            if self.input[self.pos:self.pos+2] == '*/':
                self.pos += 2
                self.col += 2
                
                # Create token for the comment
                comment_text = self.input[start_pos:self.pos]
                token = XeroxToken(
                    type='comment',
                    value=comment_text,
                    line_number=start_line,
                    column=start_col
                )
                self.tokens.append(token)
                return
            
            if self.input[self.pos] == '\n':
                self.line += 1
                self.col = 1
            else:
                self.col += 1
            
            self.pos += 1
        
        # If we get here, the comment was never closed
        logger.warning(f"Unclosed block comment starting at line {start_line}, column {start_col}")
        
        # Still create a token for the unclosed comment
        comment_text = self.input[start_pos:self.pos]
        token = XeroxToken(
            type='comment',
            value=comment_text,
            line_number=start_line,
            column=start_col
        )
        self.tokens.append(token)
    
    def _handle_line_comment(self):
        """Handle a % comment that goes to the end of the line."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        
        while self.pos < len(self.input) and self.input[self.pos] != '\n':
            self.pos += 1
            self.col += 1
        
        # Create token for the comment
        comment_text = self.input[start_pos:self.pos]
        token = XeroxToken(
            type='comment',
            value=comment_text,
            line_number=start_line,
            column=start_col
        )
        self.tokens.append(token)
    
    def _handle_string_literal(self, quote_char):
        """Handle a string literal."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        self.pos += 1  # Skip opening quote
        self.col += 1
        
        escaped = False
        
        while self.pos < len(self.input):
            if escaped:
                escaped = False
            elif self.input[self.pos] == '\\':
                escaped = True
            elif self.input[self.pos] == quote_char:
                self.pos += 1
                self.col += 1
                
                # Create token for the string including quotes
                string_text = self.input[start_pos:self.pos]
                token = XeroxToken(
                    type='string',
                    value=string_text,
                    line_number=start_line,
                    column=start_col
                )
                self.tokens.append(token)
                return
            
            if self.input[self.pos] == '\n':
                self.line += 1
                self.col = 1
            else:
                self.col += 1
            
            self.pos += 1
        
        # If we get here, the string was never closed
        logger.warning(f"Unclosed string starting at line {start_line}, column {start_col}")
        
        # Still create a token for the unclosed string
        string_text = self.input[start_pos:self.pos]
        token = XeroxToken(
            type='string',
            value=string_text,
            line_number=start_line,
            column=start_col
        )
        self.tokens.append(token)
    
    def _handle_number(self):
        """Handle a numeric literal."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        
        # Handle base prefixes (hex, octal, etc.)
        if self.input[self.pos:self.pos+2].lower() == '0x':
            self.pos += 2
            self.col += 2
            while self.pos < len(self.input) and (self.input[self.pos].isdigit() or 
                                             self.input[self.pos].lower() in 'abcdef'):
                self.pos += 1
                self.col += 1
        else:
            # Regular decimal number
            while self.pos < len(self.input) and (self.input[self.pos].isdigit() or 
                                             self.input[self.pos] == '.'):
                self.pos += 1
                self.col += 1
        
        # Create token for the number
        number_text = self.input[start_pos:self.pos]
        token = XeroxToken(
            type='number',
            value=number_text,
            line_number=start_line,
            column=start_col
        )
        self.tokens.append(token)
    
    def _handle_identifier(self):
        """Handle an identifier or keyword."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        
        while self.pos < len(self.input) and (self.input[self.pos].isalnum() or 
                                         self.input[self.pos] in '_$'):
            self.pos += 1
            self.col += 1
        
        # Check if it's a keyword
        identifier = self.input[start_pos:self.pos]
        if identifier.upper() in self.KEYWORDS:
            token = XeroxToken(
                type='keyword',
                value=identifier,
                line_number=start_line,
                column=start_col
            )
        else:
            token = XeroxToken(
                type='identifier',
                value=identifier,
                line_number=start_line,
                column=start_col
            )
        
        self.tokens.append(token)
    
    def _handle_xerox_identifier(self):
        """Handle a Xerox-specific identifier that starts with /."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        self.pos += 1  # Skip /
        self.col += 1
        
        while self.pos < len(self.input) and (self.input[self.pos].isalnum() or 
                                         self.input[self.pos] in '_$'):
            self.pos += 1
            self.col += 1
        
        # Create token for the Xerox identifier
        identifier = self.input[start_pos:self.pos]
        token = XeroxToken(
            type='variable',
            value=identifier,
            line_number=start_line,
            column=start_col
        )
        self.tokens.append(token)
    
    def _handle_operator(self):
        """Handle an operator."""
        start_line = self.line
        start_col = self.col
        start_pos = self.pos
        
        # Check for two-character operators
        if self.pos + 1 < len(self.input):
            potential_op = self.input[self.pos:self.pos+2]
            if potential_op in self.OPERATORS:
                self.pos += 2
                self.col += 2
                
                token = XeroxToken(
                    type='operator',
                    value=potential_op,
                    line_number=start_line,
                    column=start_col
                )
                self.tokens.append(token)
                return
        
        # Single-character operator
        token = XeroxToken(
            type='operator',
            value=self.input[self.pos],
            line_number=start_line,
            column=start_col
        )
        self.tokens.append(token)
        self.pos += 1
        self.col += 1

# ===== SECTION 5: PARSER CLASS =====
# Should have a complete XeroxParser class
class XeroxParser:
    """Parser for Xerox FreeFlow code."""
    
    def __init__(self):
        self.lexer = XeroxLexer()
        self.tokens = []
        self.pos = 0
        
    def parse_file(self, filename: str) -> Union[XeroxDBM, XeroxFRM]:
        """Parse a Xerox file and return the appropriate structure."""
        try:
            logger.info(f"Parsing file: {filename}")
            with open(filename, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
            
            # Determine file type
            if filename.lower().endswith('.dbm'):
                return self.parse_dbm(filename, content)
            elif filename.lower().endswith('.frm'):
                return self.parse_frm(filename, content)
            else:
                logger.warning(f"Unknown file type: {filename}")
                # Try to guess based on content
                if 'STARTDBM' in content:
                    return self.parse_dbm(filename, content)
                else:
                    return self.parse_frm(filename, content)
                
        except UnicodeDecodeError:
            # Try again with latin-1 encoding
            logger.info(f"Retrying with latin-1 encoding: {filename}")
            with open(filename, 'r', encoding='latin-1') as f:
                content = f.read()
            
            if filename.lower().endswith('.dbm'):
                return self.parse_dbm(filename, content)
            elif filename.lower().endswith('.frm'):
                return self.parse_frm(filename, content)
            else:
                # Try to guess based on content
                if 'STARTDBM' in content:
                    return self.parse_dbm(filename, content)
                else:
                    return self.parse_frm(filename, content)
    
    def parse_dbm(self, filename: str, content: str) -> XeroxDBM:
        """Parse DBM content and return a structured representation."""
        logger.info(f"Parsing as DBM: {filename}")
        dbm = XeroxDBM(filename=filename, raw_content=content)
        
        # Tokenize the content
        self.tokens = self.lexer.tokenize(content)
        dbm.tokens = self.tokens
        self.pos = 0
        
        # Extract metadata
        dbm.title, dbm.creator, dbm.creation_date = self._extract_metadata()
        
        # Extract WIZVAR fields if present
        dbm.wizvar_prefixes, dbm.wizvar_fields = self._extract_wizvar()
        
        # Parse declarations and case blocks
        self._parse_dbm_structure(dbm)
        
        return dbm
    
    def parse_frm(self, filename: str, content: str) -> XeroxFRM:
        """Parse FRM content and return a structured representation."""
        logger.info(f"Parsing as FRM: {filename}")
        frm = XeroxFRM(filename=filename, raw_content=content)
        
        # Tokenize the content
        self.tokens = self.lexer.tokenize(content)
        frm.tokens = self.tokens
        self.pos = 0
        
        # Extract metadata
        frm.title, frm.creator, frm.creation_date = self._extract_metadata()
        
        # Parse form structure
        self._parse_frm_structure(frm)
        
        return frm
    
    def _extract_metadata(self) -> Tuple[str, str, str]:
        """Extract metadata from comments at the start of the file."""
        title = ""
        creator = ""
        creation_date = ""
        
        # Look for metadata in the first few tokens
        for i, token in enumerate(self.tokens[:20]):
            if token.type == 'comment':
                if '%%Title:' in token.value:
                    title = token.value.split('%%Title:')[1].strip()
                elif '%%Creator:' in token.value:
                    creator = token.value.split('%%Creator:')[1].strip()
                elif '%%CreationDate:' in token.value:
                    creation_date = token.value.split('%%CreationDate:')[1].strip()
        
        return title, creator, creation_date
    
    def _extract_wizvar(self) -> Tuple[List[str], List[str]]:
        """Extract WIZVAR prefixes and fields from the file."""
        prefixes = []
        fields = []
        
        # Look for WIZVAR:BEGIN and WIZVAR:END sections
        in_wizvar = False
        for token in self.tokens:
            if token.type == 'comment' and '%%WIZVAR:BEGIN' in token.value:
                in_wizvar = True
                continue
            
            if token.type == 'comment' and '%%WIZVAR:END' in token.value:
                in_wizvar = False
                continue
            
            if in_wizvar and token.type == 'comment' and '%%WIZVAR' in token.value:
                # Parse the WIZVAR line
                parts = token.value.replace('%%WIZVAR', '').strip().split(',')
                for part in parts:
                    var_name = part.strip()
                    if var_name.startswith('PREFIX'):
                        prefixes.append(var_name)
                    else:
                        fields.append(var_name)
        
        return prefixes, fields
    
    def _parse_dbm_structure(self, dbm: XeroxDBM):
        """Parse the structure of a DBM file."""
        # Reset position
        self.pos = 0
        
        # Flags for tracking sections
        in_case_block = False
        current_case = ""
        current_command = None
        
        while self.pos < len(self.tokens):
            token = self.tokens[self.pos]
            
            # Handle font definitions
            if (token.type == 'variable' and 
                self.pos + 4 < len(self.tokens) and
                self.tokens[self.pos + 2].type == 'variable' and
                self.tokens[self.pos + 4].value == 'INDEXFONT'):
                
                alias = token.value
                font_name = self.tokens[self.pos + 2].value
                size = float(self.tokens[self.pos + 3].value)
                
                dbm.fonts[alias.lstrip('/')] = XeroxFont(
                    alias=alias.lstrip('/'),
                    name=font_name.lstrip('/'),
                    size=size
                )
                
                self.pos += 5
                continue
            
            # Handle color definitions
            if (token.type == 'variable' and 
                self.pos + 2 < len(self.tokens) and
                self.tokens[self.pos + 2].value == 'INDEXCOLOR'):
                
                alias = token.value
                color_name = self.tokens[self.pos + 1].value
                
                dbm.colors[alias.lstrip('/')] = XeroxColor(
                    alias=alias.lstrip('/'),
                    name=color_name.lstrip('/')
                )
                
                self.pos += 3
                continue
            
            # Handle variable definitions with SETVAR
            if (token.type == 'variable' and 
                self.pos + 2 < len(self.tokens) and
                self.tokens[self.pos + 2].value == 'SETVAR'):
                
                var_name = token.value
                var_value = self.tokens[self.pos + 1].value
                
                dbm.variables[var_name.lstrip('/')] = XeroxVariable(
                    name=var_name.lstrip('/'),
                    default_value=var_value
                )
                
                self.pos += 3
                continue
            
            # Handle CASE PREFIX
            if token.value == 'CASE' and self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1].value == 'PREFIX':
                in_case_block = True
                self.pos += 2
                continue
            
            # Handle case values (in parentheses or braces)
            if in_case_block and token.type == 'delimiter' and token.value == '(':
                # Extract case value
                case_start = self.pos
                case_value = ""
                self.pos += 1
                
                while self.pos < len(self.tokens) and self.tokens[self.pos].type != 'delimiter':
                    case_value += self.tokens[self.pos].value
                    self.pos += 1
                
                if self.pos < len(self.tokens) and self.tokens[self.pos].value == ')':
                    current_case = case_value
                    dbm.case_blocks[current_case] = []
                    self.pos += 1
                    continue
                else:
                    # If we didn't find closing parenthesis, reset position
                    self.pos = case_start + 1
            
            # Handle empty case ({})
            if in_case_block and token.type == 'delimiter' and token.value == '{':
                if self.pos + 1 < len(self.tokens) and self.tokens[self.pos + 1].value == '}':
                    current_case = "{}"
                    dbm.case_blocks[current_case] = []
                    self.pos += 2
                    continue
            
            # Collect commands within a case block
            if in_case_block and current_case:
                # Check for end of case (ENDCASE)
                if token.value == 'ENDCASE':
                    in_case_block = False
                    current_case = ""
                    self.pos += 1
                    continue
                
                # Regular command within a case
                if token.type in ('keyword', 'identifier'):
                    cmd = XeroxCommand(
                        name=token.value,
                        line_number=token.line_number,
                        column=token.column
                    )
                    
                    # Collect parameters until semicolon
                    self.pos += 1
                    while self.pos < len(self.tokens) and self.tokens[self.pos].value != ';':
                        cmd.parameters.append(self.tokens[self.pos].value)
                        self.pos += 1
                    
                    if self.pos < len(self.tokens) and self.tokens[self.pos].value == ';':
                        self.pos += 1
                    
                    dbm.case_blocks[current_case].append(cmd)
                    dbm.commands.append(cmd)
                    continue
            
            # Move to next token if none of the above matched
            self.pos += 1
    
    def _parse_frm_structure(self, frm: XeroxFRM):
        """Parse the structure of an FRM file."""
        # Reset position
        self.pos = 0
        
        # Flags for tracking sections
        in_form_block = False
        current_command = None
        
        while self.pos < len(self.tokens):
            token = self.tokens[self.pos]
            
            # Check for form start
            if token.type == 'delimiter' and token.value == '{' and self.pos + 2 < len(self.tokens):
                if (self.tokens[self.pos + 1].type == 'comment' and 
                    '%%Begin Form' in self.tokens[self.pos + 1].value):
                    in_form_block = True
                    self.pos += 2
                    continue
            
            # Check for form end
            if token.type == 'delimiter' and token.value == '}' and self.pos + 1 < len(self.tokens):
                if (self.tokens[self.pos + 1].type == 'comment' and 
                    '%FSHOW' in